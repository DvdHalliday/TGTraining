#pragma once

template<typename T>
class TDynamicArray
{
private:
	int Size = 0;
	int Capacity = 1;
	T* Data = new T[Capacity];

	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	void CopyData(int NewCapacity)
	{
		T* NewData = new T[NewCapacity];

		for (int i = 0; i < Size; i++)
		{
			NewData[i] = Data[i];
		}

		Capacity = NewCapacity;

		delete[] Data;
		Data = NewData;
		NewData = nullptr;
	}

public:
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	TDynamicArray() {}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	~TDynamicArray()
	{
		delete[] Data;
		Data = nullptr;
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	T& operator[](int Index)
	{
		return Data[Index];
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	const T& operator[](int Index) const
	{
		return Data[Index];
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	T& Front()
	{
		return Data[0];
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	const T& Front() const
	{
		return Data[0];
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	T& Back()
	{
		return Data[Size - 1];
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	const T& Back() const
	{
		return Data[Size - 1];
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	T* GetData()
	{
		return &Data[0];
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	const T* GetData() const
	{
		return &Data[0];
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	bool IsEmpty() const
	{
		return Size == 0;
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	int GetSize() const
	{
		return Size;
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	int GetCapacity() const
	{
		return Capacity;
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	void Reserve(const int NewCapacity)
	{
		if (NewCapacity > Capacity)
		{
			CopyData(NewCapacity);
		}
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	void ShrinkToFit()
	{
		if (Capacity > Size)
		{
			CopyData(Size);
		}
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	void Clear()
	{
		Size = 0;
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	void PushBack(const T& NewItem)
	{
		if (Size == Capacity)
		{
			Reserve(Capacity * 2);
		}

		Data[Size++] = NewItem;
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	void PopBack()
	{
		Size--;
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	void Insert(const T& Item, const int Index)
	{
		if (Index >= 0 && Index <= Size)
		{
			// If the index is exactly after the Back item, we can just push it and get on with it
			if (Index == Size)
			{
				PushBack(Item);
				return;
			}
			// If this isn't the case, we can just start by pushing our last element back, this way we won't have to deal with more Reserves, and we would've done this anyway
			PushBack(Back());
			// Now it's time to copy every element that still needs to be moved
			for (int i = Size - 2; i >= Index; i--)
			{
				Data[i + 1] = Data[i];
			}

			Data[Index] = Item;
		}
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	void Erase(const int Index)
	{
		if (Index >= 0 && Index < Size)
		{
			for (int i = Index; i < Size - 1; i++)
			{
				Data[i] = Data[i + 1];
			}

			PopBack();
		}
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	void Resize(const int NewSize)
	{
		if (NewSize <= Size)
		{
			Size = NewSize;
			return;
		}
		else if (NewSize > Capacity)
		{
			Reserve(NewSize);
		}

		Size = NewSize;
	}
	//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	void Append(const TDynamicArray<T>& Other)
	{
		Reserve(Size + Other.Size);

		for (int i = 0; i < Other.Size; i++)
		{
			PushBack(Other[i]);
		}
	}
};
